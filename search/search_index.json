{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-buzz","text":"<p>That's not flying, it's falling with style</p> <p>Take Exceptions to infinity...and beyond with <code>py-buzz</code>!</p>"},{"location":"#overview","title":"Overview","text":"<p>py-buzz supplies some useful tools to use with python exceptions as well as a base Buzz exception class that includes them as classmethods.</p> <p>py-buzz is fully equipped with an arsenal of helpful tools to replace boilerplate code that appear over and over again in python projects such as:</p> <ul> <li>checking conditions and raising errors on failure (<code>require_conditon</code>)</li> <li>checking that values are defined and raising errors if not (<code>enforce_defined</code>)</li> <li>catching exceptions and wrapping them in clearer exception types with better error   messages (<code>handle_errors</code>)</li> <li>checking many conditions and reporting which ones failed (<code>check_expressions</code>)</li> </ul> <p>py-buzz provides two different main use-cases:</p> <p>It provides a set of functions that can be used with any exceptions. So, if you already have a set of custom exceptions or simply wish to use existing exceptinos, you can use the py-buzz functions like <code>require_condition</code>, <code>handle_errors</code>, <code>enforce_defined</code>, and so on with those pre-existing exception types.</p> <p>It also prived the <code>Buzz</code> exception class that can be used  as a bass class for custom exceptions within a project.</p> <p>Either use-case allows the user to focus on clear and concise error handling in their code base without having to re-write the same error handling code over and over or having to re-write convenience functions themselves.</p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or greater</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>This will install the latest release of py-buzz from pypi via pip:</p> <pre><code>pip install py-buzz\n</code></pre>"},{"location":"#using","title":"Using","text":"<p>Just import!</p> <pre><code>from buzz import require_condition\n\nrequire_condition(check_something(), \"The check failed!\")\n</code></pre> <p>For more examples of usage, see the Features page.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#main-features","title":"Main Features","text":"<p>There are a few main features of <code>py-buzz</code> that are noteworthy:</p>"},{"location":"features/#raise-exception-on-condition-failure","title":"Raise exception on condition failure","text":"<p>The <code>py-buzz</code> package provides a function that checks a condition and raises an exception if it fails. This is nice, because you often find your self writing a lot of <code>if &lt;whatever&gt;: raise Exception(&lt;message&gt;)</code> throughout your code base. It's just a little easier with <code>py-buzz</code>:</p> <pre><code># Vanilla python\nif not some_condition():\n    raise Exception(\"some_condition failed\")\n\n# With py-buzz\nrequire_condition(some_condition(), \"some_condition failed\")\n</code></pre> <p>This is mostly just a bit of syntactic sugar, but it can make your code a bit more palletable. This is especially true in functions that need to check a lot of conditions before prior to executing their core logic.</p> <p>You may also specify the exception type that should be raised by passing it to the <code>raise_exc_class</code> parameter:</p> <pre><code>require_condition(\n    some_condition(),\n    \"some_condition failed\",\n    raise_exc_class=MyProjectError,\n)\n</code></pre> <p>In this case, a <code>MyProjectError</code> would be raised if the condition fails.</p> <p>There are a few special keyword argument parameters for the <code>require_condition()</code> function:</p>"},{"location":"features/#raise_exc_class","title":"raise_exc_class","text":"<p>This just specifies the type of exception to raise if the condition fails. It defaults to <code>Exception</code>.</p>"},{"location":"features/#raise_args","title":"raise_args","text":"<p>With this parameter, you can specify any positional arguments that should be passed to the raised exception after the message. Here is an example:</p> <pre><code>\nclass MyProjectError(Exception):\n    def __init__(self, message, init_arg1, init_arg2):\n        self.init_arg1 = init_arg1\n        self.init_arg2 = init_arg2\n\nrequire_condition(\n    some_condition(),\n    \"some_condition failed\",\n    raise_exc_class=MyProjectError,\n    raise_args=[\"foo\", \"bar\"],\n)\n</code></pre> <p>If the condition fails, <code>require_condition</code> will rais a <code>MyProjectError</code> initialized with positional args <code>init_arg1 == \"foo\"</code> and <code>init_arg2 == \"bar\"</code>.</p>"},{"location":"features/#raise_kwargs","title":"raise_kwargs","text":"<p>Like the <code>raise_args</code> parameter, this one passes along a dictionary of keyword arguments to the newly raised exception:</p> <pre><code>class MyProjectError(Exception):\n    def __init__(self, message, init_kwarg1=None, init_kwarg2=None):\n        self.init_kwarg1 = init_kwarg1\n        self.init_kwarg2 = init_kwarg2\n\nrequire_condition(\n    some_condition(),\n    \"some_condition failed\",\n    raise_exc_class=MyProjectError,\n    raise_kwargs=dict(\"foo\", \"bar\"),\n)\n</code></pre> <p>If the condition fails, <code>require_condition</code> will rais a <code>MyProjectError</code> initialized with keyword arguments <code>init_kwarg1 == \"foo\"</code> and <code>init_kwarg2 == \"bar\"</code>.</p>"},{"location":"features/#exc_builder","title":"exc_builder","text":"<p>If the exception to be raised with the <code>raise_exc_class</code> option is a non-standard exception type that does not take a string message as its first argument, you will need to use an alternative exception builder that knows how to map the exception parts to the correct place.</p> <p>For example, FastAPI's <code>HTTPException</code> takes a <code>status_code</code> as its first positional argument and expects that any message details are passed as a keyword argument named <code>details</code>.</p> <p>In this case, you need to define a builder function to construct the exception and pass it to the <code>exc_builder</code> option:</p> <pre><code>class WeirdArgsError(Exception):\n    def __init__(self, weird_arg, detail=\"\"):\n        self.weird_arg = weird_arg\n        self.detail = detail\n\ndef weird_builder(exc_class, message, *args, **kwargs):\n    return exc_class(*args, detail=message, **kwargs)\n\nrequire_condition(\n    some_condition(),\n    \"some_condition failed\",\n    raise_exc_class=WeirdArgsError,\n    raise_kwargs=dict(\"foo\", \"bar\"),\n    exc_builder=weird_builder,\n)\n</code></pre>"},{"location":"features/#raise-exception-if-value-is-not-defined","title":"Raise exception if value is not defined","text":"<p>The <code>py-buzz</code> package provides a function that checks a value and raises an exception if it is not defined. This is especially useful for both checking if a variable passed to a function is defined and also to satisfy static type checkers when you want to call a method on the object.</p> <pre><code>    # Vanilla python\n    def vanilla(val: Optional[str]):\n        if val is None:\n            raise Exception(\"Received an undefined value!\")\n        return val.upper()\n\n    # With py-buzz\n    def buzzy(val: Optional[str]):\n        val = enforce_defined(val)\n        return val.upper()\n</code></pre> <p>This is also mostly just syntactic sugar, but it save you a few lines of code and is still very expressive. It might also be useful if you need to supply some more context in your error:</p> <pre><code>def neopolitan(val: Optional[str]):\n    val = enforce_defined(\n        val,\n        \"Received an undefined value!\"\n        raise_exc_class=MyProjectError,\n        raise_args=[\"foo\", \"bar\"],\n        raise_kwargs=dict(baz=\"QUX\"),\n    )\n    return val\n</code></pre> <p>In this case, a <code>MyProjectError</code> with be raised with positional arguments of <code>\"foo\"</code> and <code>\"bar\"</code> and a keyword argument of <code>baz=\"QUX\"</code> if the value passed in is not defined.</p> <p>By default, <code>enforce_defined()</code> raises an exception with a basic message saying that the value was not defined. However, you may pass in a custom message with the <code>message</code> keyword argument. Like <code>require_condition()</code>, the <code>enforce_defined()</code> function also accepts the <code>raise_exc_class</code>, <code>raise_args</code>, <code>raise_kwargs</code>, and <code>exc_builder</code> keyword arguments.</p>"},{"location":"features/#exception-handling-context-manager","title":"Exception handling context manager","text":"<p>The <code>py-buzz</code> package also provides a context manager that catches any exceptions that might be raised while executing a bit of code. The caught exceptions are re-packaged and raised as another exception type. The message attahed to the new expression captures the initial exception's message:</p> <pre><code># Vanilla python\ntry:\n    this_could_fail()\n    this_could_also_fail()\n    this_will_definitely_fail()\nexcept Exception as err:\n    raise RuntimeError(f\"Something didn't work -- Error: {err}\")\n\n# With py-buzz\nwith handle_errors(\"Something didn't work\", raise_exc_class=RuntimeError):\n    this_could_fail()\n    this_could_also_fail()\n    this_will_definitely_fail()\n</code></pre> <p>This actually can save a bit of code and makes things a bit cleaner. It is also a implements pattern that tends to get repeated over and over again. If you need to do very complicated things while handling an exception, you should use a standard try- catch block. However, there are some extra bells and whistles on <code>handle_errors</code> that can be used by passing additional keyword arguments to the function.</p>"},{"location":"features/#raise_exc_class_1","title":"raise_exc_class","text":"<p>This parameter is the same as for <code>require_condition()</code>. However, if you pass <code>None</code> it will not raise a new exception. Instead, <code>handle_errors</code> will process the <code>do_except</code>, <code>do_else</code>, and <code>do_finally</code> methods and then continue. This effectively absorbs any exceptions that occur in the context. However the context is immediately exited after the first raised exception.</p>"},{"location":"features/#raise_args_1","title":"raise_args","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#raise_kwargs_1","title":"raise_kwargs","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#exc_builder_1","title":"exc_builder","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#handle_exc_class","title":"handle_exc_class","text":"<p>This option describes the type of exception that will be handled by this context manager. Any instance of the option's exception (or any of it's derived exception classes) will be caught. This is very useful if you only want to handle a certain category of exceptions and let the others rise up un-altered:</p> <pre><code>with handle_errors(\"Something went wrong\", handle_exc_class=MyProjectError):\n   some_function_that_could_raise_mine_or_other_errors()\n</code></pre> <p>Exception instances that do not fall within the inheritance tree of the <code>handle_exc_class</code> option will not be handled at all. It is worth noting that the <code>do_except</code> task will not be executed if another exception type occurs. However, the <code>do_else</code> and <code>do_finally</code> tasks will be executed normally.</p>"},{"location":"features/#do_except","title":"do_except","text":"<p>Often, it is useful to do some particular things when an exception is caught.  Most frequently this includes logging the exception. The <code>do_except</code> optional argument provides the ability to do this. The <code>do_except</code> option should be a callable function that accepts a paramter of type <code>DoExceptParams</code> that can be imported from <code>buzz</code>. This <code>dataclass</code> has three attributes:</p> <ul> <li>err: The caught exception itself</li> <li>final_message: A message describing the error (This will be the formatted error message)</li> <li>trace: A stack trace</li> </ul> <p>This option might be invoked something like this:</p> <pre><code>def log_error(dep: DoExceptParams):\n    logger.error(dep.final_message)\n    logger.error('\\n'.join(dep.trace))\n\nwith handle_errors(\"Something went wrong\", do_except=log_error):\n    some_dangerous_function()\n</code></pre>"},{"location":"features/#do_else","title":"do_else","text":"<p>This option describes some action that should happen if no exceptions are encountered. This option is less useful than <code>do_except</code> but it may useful in some circumstances. This option should be a callable that takes no arguments:</p> <pre><code>    def log_yay():\n        logger.info(\"we did it!\")\n\n    with handle_errors(\"Something went wrong\", do_else=log_yay):\n        some_not_dangerous_function()\n</code></pre>"},{"location":"features/#do_finally","title":"do_finally","text":"<p>This option describes some action that should happen at the end of the context regardless to whether an exception occurred or not. This is a useful feature if you need to do some cleanup in either case. It should take a callable that receives no arguments:</p> <pre><code>def close_resource():\n    resource.close()\n\nwith handle_errors(\"Something went wrong\", do_finally=close_resource):\n    some_dangerous_function_that_uses_resource(resource)\n</code></pre>"},{"location":"features/#additional-features","title":"Additional Features","text":""},{"location":"features/#check_expressions","title":"check_expressions","text":"<p>The <code>check_expressions</code> context manager is used to check multiple expressions inside of a context manager. Each expression is checked and each failing expression is reported at the end in a raised exception. If no expressions fail in the block, no exception is raised.</p> <pre><code>with check_expressions(main_message='there will be errors') as check:\n    check(True)\n    check(False)\n    check(1 == 2, \"one is not two\")\n    check('cooooooool', 'not a problem')\n    check(0, \"zero is still zero\")\n</code></pre> <p>If the above code was executed, an exception would be raised that looks like this:</p> <pre><code>Exception: Checked expressions failed: there will be errors\n   2: 2nd expression failed\n   3: one is not two\n   5: zero is still zero\n</code></pre> <p>The <code>check_expressions()</code> also accepts some keyword arguments:</p>"},{"location":"features/#raise_exc_class_2","title":"raise_exc_class","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#raise_args_2","title":"raise_args","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#raise_kwargs_2","title":"raise_kwargs","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#exc_builder_2","title":"exc_builder","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#reformat_exception","title":"reformat_exception","text":"<p>This method is used internally by the <code>handle_errors</code> context manager.  However, it is sometimes useful in other circumstances. It simply allows you to wrap an exception message in a more informative block of text:</p> <pre><code>try:\n    raise ValueError(\"I didn't like that\")\nexcept Exception as err:\n    print(reformat_exception(\"welp...that didn't work\", err))\n</code></pre> <p>The above block would result in output like:</p> <pre><code>&gt; welp...that didn't work -- ValueError: I didn't like that\n</code></pre>"},{"location":"features/#get_traceback","title":"get_traceback","text":"<p>This function is just a tool to fetch the traceback for the current function. It does this by fetching it out of <code>sys.exc_info</code>. It is used internally with Buzz but could be useful in other contexts.</p>"},{"location":"features/#the-buzz-base-class","title":"The Buzz base class","text":"<p>All of the methods described above are attached to the special exception class, <code>Buzz</code>. You could, for example, use this as the base exception type for your project and then access all the functions of <code>py-buzz</code> from that exception type:</p> <pre><code>from buzz import Buzz\n\nclass MyProjectError(Buzz):\n    pass\n\nMyProjectError.require_condition(check_vals(), \"Value check failed!\")\n</code></pre> <p>The code above would raise a <code>MyProjectError</code> with the supplied message if the condition expression was falsey.</p> <p>The <code>Buzz</code> base class provides the same sort of access for <code>handle_errors</code>, <code>enforce_defined</code>, and <code>check_expressions</code>.</p> <p>Check out the examples for more.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#buzz.tools","title":"buzz.tools","text":"<p>This module supplies the core functions of the py-buzz package.</p>"},{"location":"reference/#buzz.tools.DoExceptParams","title":"DoExceptParams  <code>dataclass</code>","text":"<p>Dataclass for the <code>do_except</code> user supplied handling method.</p> <p>Attributes:</p> Name Type Description <code>err</code> <code>Exception</code> <p>The exception instance itself.</p> <code>final_message</code> <code>str</code> <p>The final, combined message</p> <code>trace</code> <code>types.TracebackType | None</code> <p>A traceback of the exception</p>"},{"location":"reference/#buzz.tools.check_expressions","title":"check_expressions","text":"<pre><code>check_expressions(\n    main_message: str,\n    raise_exc_class: type[Exception] = Exception,\n    raise_args: Iterable[Any] | None = None,\n    raise_kwargs: Mapping[str, Any] | None = None,\n    exc_builder: Callable[\n        ..., Exception\n    ] = default_exc_builder,\n)\n</code></pre> <p>Check a series of expressions inside of a context manager. If any fail an exception is raised that contains a main message and a description of each failing expression.</p> <p>Parameters:</p> Name Type Description Default <code>main</code> <code>message</code> <p>The main failure message to include in the constructed message that is passed to the                raised Exception</p> required <code>raise_exc_class</code> <code>type[Exception]</code> <p>The exception type to raise with the constructed message if the expression is falsey.</p> <pre><code>           Defaults to Exception.\n\n           May not be None.\n</code></pre> <code>Exception</code> <code>raise_args</code> <code>Iterable[Any] | None</code> <p>Additional positional args (after the constructed message) that will passed when raising                an instance of the <code>raise_exc_class</code>.</p> <code>None</code> <code>raise_kwargs</code> <code>Mapping[str, Any] | None</code> <p>Keyword args that will be passed when raising an instance of the <code>raise_exc_class</code>.</p> <code>None</code> Example <p>The following is an example usage::</p> <pre><code>with check_expressions(\"Something wasn't right\") as check:\n    check(a is not None)\n    check(a &gt; b, \"a must be greater than b\")\n    check(a != 1, \"a must not equal 1\")\n    check(b &gt;= 0, \"b must not be negative\")\n</code></pre> <p>This would render output like::</p> <pre><code>Checked expressions failed: Something wasn't right:\n  1: first expressoin failed\n  3: a must not equal 1\n</code></pre>"},{"location":"reference/#buzz.tools.default_exc_builder","title":"default_exc_builder","text":"<pre><code>default_exc_builder(\n    exc: type[TExc], message: str, *args: str, **kwargs: str\n) -&gt; TExc\n</code></pre> <p>Build an exception instance using default behavior where message is passed as first positional argument.</p> <p>Some exception types such as FastAPI's HTTPException do not take a message as the first positional argument, so they will need a different exception builder.</p>"},{"location":"reference/#buzz.tools.enforce_defined","title":"enforce_defined","text":"<pre><code>enforce_defined(\n    value: TNonNull | None,\n    message: str = \"Value was not defined (None)\",\n    raise_exc_class: type[Exception] = Exception,\n    raise_args: Iterable[Any] | None = None,\n    raise_kwargs: Mapping[str, Any] | None = None,\n    exc_builder: Callable[\n        ..., Exception\n    ] = default_exc_builder,\n) -&gt; TNonNull\n</code></pre> <p>Assert that a value is not None. If the assertion fails, raise an exception with the supplied message.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>TNonNull | None</code> <p>The value that is checked to be non-null</p> required <code>message</code> <code>str</code> <p>The failure message to attach to the raised Exception</p> <code>'Value was not defined (None)'</code> <code>expr</code> <p>The value that is checked for truthiness (usually an evaluated expression)</p> required <code>raise_exc_class</code> <code>type[Exception]</code> <p>The exception type to raise with the constructed message if the expression is falsey.</p> <pre><code>          Defaults to Exception.\n          May not be None.\n</code></pre> <code>Exception</code> <code>raise_args</code> <code>Iterable[Any] | None</code> <p>Additional positional args (after the constructed message) that will passed when raising               an instance of the <code>raise_exc_class</code>.</p> <code>None</code> <code>raise_kwargs</code> <code>Mapping[str, Any] | None</code> <p>Keyword args that will be passed when raising an instance of the <code>raise_exc_class</code>.</p> <code>None</code>"},{"location":"reference/#buzz.tools.get_traceback","title":"get_traceback","text":"<pre><code>get_traceback() -&gt; types.TracebackType | None\n</code></pre> <p>Retrieves the traceback after an exception has been raised.</p>"},{"location":"reference/#buzz.tools.handle_errors","title":"handle_errors","text":"<pre><code>handle_errors(\n    message: str,\n    raise_exc_class: type[Exception] | None = Exception,\n    raise_args: Iterable[Any] | None = None,\n    raise_kwargs: Mapping[str, Any] | None = None,\n    handle_exc_class: type[Exception]\n    | Tuple[type[Exception], ...] = Exception,\n    do_finally: Callable[[], None] = noop,\n    do_except: Callable[[DoExceptParams], None] = noop,\n    do_else: Callable[[], None] = noop,\n    exc_builder: Callable[\n        ..., Exception\n    ] = default_exc_builder,\n) -&gt; Iterator[None]\n</code></pre> <p>Provide a context manager that will intercept exceptions and repackage them with a message attached:</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to attach to the raised exception.</p> required <code>raise_exc_class</code> <code>type[Exception] | None</code> <p>The exception type to raise with the constructed message if an exception is caught in the                managed context.</p> <pre><code>           Defaults to Exception.\n\n           If ``None`` is passed, no new exception will be raised and only the ``do_except``,\n           ``do_else``, and ``do_finally`` functions will be called.\n</code></pre> <code>Exception</code> <code>raise_args</code> <code>Iterable[Any] | None</code> <p>Additional positional args (after the constructed message) that will passed when raising                an instance of the <code>raise_exc_class</code>.</p> <code>None</code> <code>raise_kwargs</code> <code>Mapping[str, Any] | None</code> <p>Keyword args that will be passed when raising an instance of the <code>raise_exc_class</code>.</p> <code>None</code> <code>handle_exc_class</code> <code>type[Exception] | Tuple[type[Exception], ...]</code> <p>Limits the class of exceptions that will be intercepted                Any other exception types will not be caught and re-packaged.                Defaults to Exception (will handle all exceptions). May also be provided as a tuple                of multiple exception types to handle.</p> <code>Exception</code> <code>do_finally</code> <code>Callable[[], None]</code> <p>A function that should always be called at the end of the block.                Should take no parameters.</p> <code>noop</code> <code>do_except</code> <code>Callable[[DoExceptParams], None]</code> <p>A function that should be called only if there was an exception. Must accept one                parameter that is an instance of the <code>DoExceptParams</code> dataclass.                Note that the <code>do_except</code> method is passed the original exception.</p> <code>noop</code> <code>do_else</code> <code>Callable[[], None]</code> <p>A function that should be called only if there were no exceptions encountered.</p> <code>noop</code> Example <p>The following is an example usage::</p> <pre><code>with handle_errors(\"It didn't work\"):\n    some_code_that_might_raise_an_exception()\n</code></pre>"},{"location":"reference/#buzz.tools.reformat_exception","title":"reformat_exception","text":"<pre><code>reformat_exception(message: str, err: Exception) -&gt; str\n</code></pre> <p>Reformat an exception by adding a message to it and reporting the original exception name and message.</p>"},{"location":"reference/#buzz.tools.require_condition","title":"require_condition","text":"<pre><code>require_condition(\n    expr: Any,\n    message: str,\n    raise_exc_class: type[Exception] = Exception,\n    raise_args: Iterable[Any] | None = None,\n    raise_kwargs: Mapping[str, Any] | None = None,\n    exc_builder: Callable[\n        ..., Exception\n    ] = default_exc_builder,\n)\n</code></pre> <p>Assert that an expression is truthy. If the assertion fails, raise an exception with the supplied message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The failure message to attach to the raised Exception</p> required <code>expr</code> <code>Any</code> <p>The value that is checked for truthiness (usually an evaluated expression)</p> required <code>raise_exc_class</code> <code>type[Exception]</code> <p>The exception type to raise with the constructed message if the expression is falsey.              Defaults to Exception.              May not be None.</p> <code>Exception</code> <code>raise_args</code> <code>Iterable[Any] | None</code> <p>Additional positional args (after the constructed message) that will passed when raising              an instance of the <code>raise_exc_class</code>.</p> <code>None</code> <code>raise_kwargs</code> <code>Mapping[str, Any] | None</code> <p>Keyword args that will be passed when raising an instance of the <code>raise_exc_class</code>.</p> <code>None</code>"},{"location":"reference/#buzz.base","title":"buzz.base","text":"<p>This module defines the Buzz base class.</p>"},{"location":"reference/#buzz.base.Buzz","title":"Buzz","text":"<p>             Bases: <code>Exception</code></p> <p>This provides a specialized exception class that wraps up all the buzz utility functions.</p>"},{"location":"reference/#buzz.base.Buzz.__init__","title":"__init__","text":"<pre><code>__init__(message)\n</code></pre> <p>Initialize the exception with a message. Dedent the supplied message.</p>"},{"location":"reference/#buzz.base.Buzz.check_expressions","title":"check_expressions  <code>classmethod</code>","text":"<pre><code>check_expressions(*args, **kwargs)\n</code></pre> <p>Call the <code>check_expressions()</code> context manager with this class as the <code>raise_exc_class</code> kwarg.</p>"},{"location":"reference/#buzz.base.Buzz.enforce_defined","title":"enforce_defined  <code>classmethod</code>","text":"<pre><code>enforce_defined(\n    value: TNonNull | None,\n    *args: TNonNull | None,\n    **kwargs: TNonNull | None\n) -&gt; TNonNull\n</code></pre> <p>Call the <code>enforce_defined()</code> function with this class as the <code>raise_exc_class</code> kwarg.</p>"},{"location":"reference/#buzz.base.Buzz.get_traceback","title":"get_traceback  <code>classmethod</code>","text":"<pre><code>get_traceback(*args, **kwargs)\n</code></pre> <p>Call the <code>get_traceback()</code> function.</p>"},{"location":"reference/#buzz.base.Buzz.handle_errors","title":"handle_errors  <code>classmethod</code>","text":"<pre><code>handle_errors(*args, re_raise = True, **kwargs)\n</code></pre> <p>Call the <code>handle_errors()</code> context manager with this class as the <code>raise_exc_class</code> kwarg.</p> Note <p>If <code>re_raise</code> is not True, <code>None</code> will be passed as the <code>raise_exc_class</code> kwarg.</p>"},{"location":"reference/#buzz.base.Buzz.require_condition","title":"require_condition  <code>classmethod</code>","text":"<pre><code>require_condition(*args, **kwargs)\n</code></pre> <p>Call the <code>require_condition()</code> function with this class as the <code>raise_exc_class</code> kwarg.</p>"}]}