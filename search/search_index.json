{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>That's not flying, it's falling with style</p> <p>Take Exceptions to infinity...and beyond with <code>py-buzz</code>!</p> <p></p>"},{"location":"#overview","title":"Overview","text":"<p>Have you ever found yourself writing the same code over and over to provide error handling in your python projects? I certainly did. In fact, I found that I often needed to re-implement the same patterns in almost every project. These patterns included:</p> <ul> <li>checking conditions and raising errors on failure</li> <li>checking that values are defined and raising errors if they are not</li> <li>catching exceptions and wrapping them in clearer exception types with better error   messages</li> <li>checking many conditions and reporting which ones failed</li> </ul> <p>This led me to create an exception toolkit called <code>py-buzz</code> that provides powerful helper tools for each of the cases listed above. The <code>py-buzz</code> package intends to make your error handling easy, expressive, and robust.</p> <p>Because <code>py-buzz</code> requires only Python itself, it's a very light-weight package that you can use in any project with very little overhead.</p> <p><code>py-buzz</code> provides functionality or two different main use-cases. Either use-case allows you to focus on clear and concise error handling in your project without a lot of repetitive code:</p>"},{"location":"#helper-functions","title":"Helper Functions","text":"<p>This set of functions can be used with any exception types. So, if you already have a set of custom exceptions or simply wish to use existing exceptions, you can import the py-buzz functions like <code>require_condition</code>, <code>handle_errors</code>, <code>enforce_defined</code>, and use them in your code immediately.</p>"},{"location":"#buzz-base-class","title":"<code>Buzz</code> base class","text":"<p>This class is meant to be used as a base class for custom exceptions that you can use in your project. <code>Buzz</code> includes all of the helper functions as class methods that will use your custom exception type.</p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or greater</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>This will install the latest release of py-buzz from pypi via pip:</p> <pre><code>pip install py-buzz\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Just import!</p> <pre><code>from buzz import require_condition\n\nrequire_condition(check_something(), \"The check failed!\")\n</code></pre> <p>For more examples of usage, see the Features page.</p>"},{"location":"changelog/","title":"Change Log","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#v600-2025-03-21","title":"v6.0.0 - 2025-03-21","text":"<ul> <li>Converted to a uv project</li> <li>Fixed typing issues</li> </ul>"},{"location":"changelog/#v502-2025-01-29","title":"v5.0.2 - 2025-01-29","text":"<ul> <li>Update docstrings and docs for <code>handle_errors_async</code></li> </ul>"},{"location":"changelog/#v501-2025-01-29","title":"v5.0.1 - 2025-01-29","text":"<ul> <li>Added <code>handle_errors_async</code> to exported list from base package</li> </ul>"},{"location":"changelog/#v500-2025-01-29","title":"v5.0.0 - 2025-01-29","text":"<ul> <li>Dropped support for Python 3.8</li> <li>Updated some dependencies</li> <li>Added <code>handle_errors_async</code></li> </ul>"},{"location":"changelog/#v420-2024-10-08","title":"v4.2.0 - 2024-10-08","text":"<ul> <li>Added <code>base_message</code> option to <code>DoExceptParams</code>.</li> <li>Changed <code>exc_builder</code> option to expect a new <code>ExcBuilderParams</code> class.</li> <li>Updated documentation.</li> </ul>"},{"location":"changelog/#v410-2022-08-31","title":"v4.1.0 - 2022-08-31","text":"<ul> <li>Added <code>ignore_exc_class</code> option to <code>handle_errors</code>.</li> </ul>"},{"location":"changelog/#v400-2022-07-30","title":"v4.0.0 - 2022-07-30","text":"<ul> <li>Dropped support for Python 3.6 and Python 3.7</li> <li>Upgraded dev dependencies including Pytest 7</li> <li>Converted documentation to markdown</li> </ul>"},{"location":"changelog/#v330-2022-06-20","title":"v3.3.0 - 2022-06-20","text":"<ul> <li>Added <code>exc_builder</code> option to all methods.</li> </ul>"},{"location":"changelog/#v321-2022-06-20","title":"v3.2.1 - 2022-06-20","text":"<ul> <li>Added <code>enforce_defined()</code> to Buzz class.</li> </ul>"},{"location":"changelog/#v320-2022-06-20","title":"v3.2.0 - 2022-06-20","text":"<ul> <li>Added <code>enforce_defined()</code> function with tests and docs.</li> </ul>"},{"location":"changelog/#v311-2022-04-05","title":"v3.1.1 - 2022-04-05","text":"<ul> <li>Added <code>raise from</code> in handle_errors (how did I miss this for so long?)</li> </ul>"},{"location":"changelog/#v310-2022-03-23","title":"v3.1.0 - 2022-03-23","text":"<ul> <li>Returned support for Python 3.6</li> </ul>"},{"location":"changelog/#v300-2022-01-15","title":"v3.0.0 - 2022-01-15","text":"<ul> <li>Moved functions to standalone tools module</li> <li>Made Buzz re-use these methods</li> <li>Changed <code>handle_errors</code> <code>exception_class</code> parameter to <code>handle_exc_class</code></li> <li>Changed <code>handle_errors</code> to send <code>DoExceptParams</code> as a single parameter</li> <li>Removed <code>sanitize_err_string</code> as it should not be needed after 2.0.0</li> <li>Removed <code>re_raise</code> parameter from handle_errors in tools.</li> <li>Made passing <code>None</code> to raise_exc_class indicate no new excepton should be raised</li> <li>Added a Makefile for running quality checks easier.</li> <li>Updated and added examples.</li> <li>Updated docs a lot.</li> <li>Dropped support for Python 3.6</li> </ul>"},{"location":"changelog/#v211-3-2021-02-16","title":"v2.1.1-3 - 2021-02-16","text":"<ul> <li>Fixed args in check_expressions</li> </ul>"},{"location":"changelog/#v210-2021-02-10","title":"v2.1.0 - 2021-02-10","text":"<ul> <li>Added ability to forward init args for derived classes</li> </ul>"},{"location":"changelog/#v200-2020-10-08","title":"v2.0.0 - 2020-10-08","text":"<ul> <li>Dropped support for python 3.5</li> <li>Removed deprecated features (format args especially)</li> <li>Added black &amp; isort pre-commit hooks</li> <li>Updated examples and doucmentation</li> <li>Updated inflection dependency version</li> </ul>"},{"location":"changelog/#v103-2019-06-05","title":"v1.0.3 - 2019-06-05","text":"<ul> <li>Added tests for use of handle_errors as a decorator</li> <li>Added deprecation warnings for removal of format args, kwargs</li> </ul>"},{"location":"changelog/#v102-2019-05-13","title":"v1.0.2 - 2019-05-13","text":"<ul> <li>Updated README</li> <li>Updated examples</li> <li>Updated quickstart docs</li> </ul>"},{"location":"changelog/#v101-2019-05-13","title":"v1.0.1 - 2019-05-13","text":"<ul> <li>Added readme to pyproject.toml</li> </ul>"},{"location":"changelog/#v100-2019-05-13","title":"v1.0.0 - 2019-05-13","text":"<ul> <li>Deprecated accumulate errors (violated priniciple of least surprise)</li> <li>Added check_expressions as a more explicit multi-expression checker</li> </ul>"},{"location":"changelog/#v040-2019-05-13","title":"v0.4.0 - 2019-05-13","text":"<ul> <li>Moved Buzz class code into base.py</li> </ul>"},{"location":"changelog/#v037-2019-04-12","title":"v0.3.7 - 2019-04-12","text":"<ul> <li>Converted project to use poetry</li> <li>Added more documentation</li> </ul>"},{"location":"changelog/#v035-2018-10-01","title":"v0.3.5 - 2018-10-01","text":"<ul> <li>Removed reformat_exception_with_traceback</li> <li>Added get_traceback. Simplicity is better</li> </ul>"},{"location":"changelog/#v035-2018-10-01_1","title":"v0.3.5 - 2018-10-01","text":"<ul> <li>Added reformat_exception_with_traceback</li> <li>Added nox support</li> </ul>"},{"location":"changelog/#v034-2018-05-09","title":"v0.3.4 - 2018-05-09","text":"<ul> <li>Fixed travis deploy collision issue</li> </ul>"},{"location":"changelog/#v033-2018-02-22","title":"v0.3.3 - 2018-02-22","text":"<ul> <li>Updated long_description so pypi wouldn't fuck me over any more</li> </ul>"},{"location":"changelog/#v032-2018-02-22","title":"v0.3.2 - 2018-02-22","text":"<ul> <li>Extracted reformat_exception method</li> </ul>"},{"location":"changelog/#v031-2017-12-21","title":"v0.3.1 - 2017-12-21","text":"<ul> <li>Version bump because pypi is complaining about version conflicts</li> </ul>"},{"location":"changelog/#v030-2017-12-21","title":"v0.3.0 - 2017-12-21","text":"<ul> <li>Added several examples to show features and complex behavior</li> <li>Added decals to README</li> </ul>"},{"location":"changelog/#v020-2017-05-18","title":"v0.2.0 - 2017-05-18","text":"<ul> <li>Added documentation, hosted on readthedocs, and such</li> </ul>"},{"location":"changelog/#v0112-2017-05-17","title":"v0.1.12 - 2017-05-17","text":"<ul> <li>Added ability to handle only specific exceptions to handle_errors</li> <li>Improved exception reporting from within handle_errors</li> </ul>"},{"location":"changelog/#v0111-2017-04-19","title":"v0.1.11 - 2017-04-19","text":"<ul> <li>Added traceback to do_except</li> </ul>"},{"location":"changelog/#v0111-2017-04-19_1","title":"v0.1.11 - 2017-04-19","text":"<ul> <li>Added ability for handle_errors to absorb exception</li> </ul>"},{"location":"changelog/#v019-2017-02-01","title":"v0.1.9 - 2017-02-01","text":"<ul> <li>Added traceback print out to handle_errors message</li> <li>Added exception class name to handle_errors output</li> </ul>"},{"location":"changelog/#v018-2016-12-30","title":"v0.1.8 - 2016-12-30","text":"<ul> <li>Added formatted message string to on_error parameters</li> <li>Renamed project to 'py-buzz'</li> <li>Added error sanitization for messages with embedded curly braces</li> </ul>"},{"location":"changelog/#v017-2016-12-22","title":"v0.1.7 - 2016-12-22","text":"<ul> <li>Fixed issues with packaging (took a lot of intermediary releases)</li> <li>Added accumulating context manager for checking expressions</li> <li>Added do_finally and on_error parameters to handle_errors</li> <li>Added repr function</li> <li>Added testing</li> </ul>"},{"location":"changelog/#v010-2016-12-15","title":"v0.1.0 - 2016-12-15","text":"<ul> <li>First release of buzz-lightyear</li> <li>This CHANGELOG</li> <li>README providing a brief overview of the project</li> </ul>"},{"location":"features/","title":"Features","text":""},{"location":"features/#main-features","title":"Main Features","text":"<p>There are a few main features of <code>py-buzz</code> that are noteworthy:</p>"},{"location":"features/#raise-exception-on-condition-failure","title":"Raise exception on condition failure","text":"<p>The <code>py-buzz</code> package provides a function that checks a condition and raises an exception if it fails. This is nice, because you often find your self writing a lot of <code>if &lt;whatever&gt;: raise Exception(&lt;message&gt;)</code> throughout your code base. It's just a little easier with <code>py-buzz</code>:</p> <pre><code># Vanilla python\nif not some_condition():\n    raise Exception(\"some_condition failed\")\n\n# With py-buzz\nrequire_condition(some_condition(), \"some_condition failed\")\n</code></pre> <p>This is mostly just a bit of syntactic sugar, but it can make your code a bit more palatable. This is especially true in functions that need to check a lot of conditions before prior to executing their core logic.</p> <p>You may also specify the exception type that should be raised by passing it to the <code>raise_exc_class</code> parameter:</p> <pre><code>require_condition(\n    some_condition(),\n    \"some_condition failed\",\n    raise_exc_class=MyProjectError,\n)\n</code></pre> <p>In this case, a <code>MyProjectError</code> would be raised if the condition fails.</p> <p>There are a few special keyword argument parameters for the <code>require_condition()</code> function:</p>"},{"location":"features/#raise_exc_class","title":"raise_exc_class","text":"<p>This just specifies the type of exception to raise if the condition fails. It defaults to <code>Exception</code>.</p>"},{"location":"features/#raise_args","title":"raise_args","text":"<p>With this parameter, you can specify any positional arguments that should be passed to the raised exception after the message. Here is an example:</p> <pre><code>class MyProjectError(Exception):\n    def __init__(self, message, init_arg1, init_arg2):\n        self.init_arg1 = init_arg1\n        self.init_arg2 = init_arg2\n\nrequire_condition(\n    some_condition(),\n    \"some_condition failed\",\n    raise_exc_class=MyProjectError,\n    raise_args=[\"foo\", \"bar\"],\n)\n</code></pre> <p>If the condition fails, <code>require_condition</code> will rais a <code>MyProjectError</code> initialized with positional args <code>init_arg1 == \"foo\"</code> and <code>init_arg2 == \"bar\"</code>.</p>"},{"location":"features/#raise_kwargs","title":"raise_kwargs","text":"<p>Like the <code>raise_args</code> parameter, this one passes along a dictionary of keyword arguments to the newly raised exception:</p> <pre><code>class MyProjectError(Exception):\n    def __init__(self, message, init_kwarg1=None, init_kwarg2=None):\n        self.init_kwarg1 = init_kwarg1\n        self.init_kwarg2 = init_kwarg2\n\nrequire_condition(\n    some_condition(),\n    \"some_condition failed\",\n    raise_exc_class=MyProjectError,\n    raise_kwargs=dict(\"foo\", \"bar\"),\n)\n</code></pre> <p>If the condition fails, <code>require_condition</code> will rais a <code>MyProjectError</code> initialized with keyword arguments <code>init_kwarg1 == \"foo\"</code> and <code>init_kwarg2 == \"bar\"</code>.</p>"},{"location":"features/#exc_builder","title":"exc_builder","text":"<p>If the exception to be raised with the <code>raise_exc_class</code> option is a non-standard exception type that does not take a string message as its first argument, you will need to use an alternative exception builder that knows how to map the exception parts to the correct place.</p> <p>For example, FastAPI's <code>HTTPException</code> takes a <code>status_code</code> as its first positional argument and expects that any message details are passed as a keyword argument named <code>details</code>.</p> <p>In this case, you need to define a builder function to construct the exception and pass it to the <code>exc_builder</code> option. The <code>exc_builder</code> option should be a callable function that accepts a single parameter of type <code>ExcBuilderParams</code> that can be imported from <code>buzz</code>.</p> <pre><code>class WeirdArgsError(Exception):\n    def __init__(self, weird_arg, detail=\"\"):\n        self.weird_arg = weird_arg\n        self.detail = detail\n\ndef weird_builder(params):\n    return exc_class(*params.raise_args, detail=params.message)\n\nrequire_condition(\n    some_condition(),\n    \"some_condition failed\",\n    raise_exc_class=WeirdArgsError,\n    raise_args=[\"weird\"],\n    exc_builder=weird_builder,\n)\n</code></pre>"},{"location":"features/#raise-exception-if-value-is-not-defined","title":"Raise exception if value is not defined","text":"<p>The <code>py-buzz</code> package provides a function that checks a value and raises an exception if it is not defined. This is especially useful for both checking if a variable passed to a function is defined and also to satisfy static type checkers when you want to call a method on the object.</p> <pre><code>    # Vanilla python\n    def vanilla(val: Optional[str]):\n        if val is None:\n            raise Exception(\"Received an undefined value!\")\n        return val.upper()\n\n    # With py-buzz\n    def buzzy(val: Optional[str]):\n        val = enforce_defined(val)\n        return val.upper()\n</code></pre> <p>This is also mostly just syntactic sugar, but it save you a few lines of code and is still very expressive. It might also be useful if you need to supply some more context in your error:</p> <pre><code>def neopolitan(val: Optional[str]):\n    val = enforce_defined(\n        val,\n        \"Received an undefined value!\"\n        raise_exc_class=MyProjectError,\n        raise_args=[\"foo\", \"bar\"],\n        raise_kwargs=dict(baz=\"QUX\"),\n    )\n    return val\n</code></pre> <p>In this case, a <code>MyProjectError</code> with be raised with positional arguments of <code>\"foo\"</code> and <code>\"bar\"</code> and a keyword argument of <code>baz=\"QUX\"</code> if the value passed in is not defined.</p> <p>By default, <code>enforce_defined()</code> raises an exception with a basic message saying that the value was not defined. However, you may pass in a custom message with the <code>message</code> keyword argument.</p> <p>The <code>enforce_defined()</code> function also accepts some keyword arguments:</p>"},{"location":"features/#raise_exc_class_1","title":"raise_exc_class","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#raise_args_1","title":"raise_args","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#raise_kwargs_1","title":"raise_kwargs","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#exc_builder_1","title":"exc_builder","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#exception-handling-context-manager","title":"Exception handling context manager","text":"<p>The <code>py-buzz</code> package also provides a context manager that catches any exceptions that might be raised while executing a bit of code. The caught exceptions are re-packaged and raised as another exception type. The message attahed to the new expression captures the initial exception's message:</p> <pre><code># Vanilla python\ntry:\n    this_could_fail()\n    this_could_also_fail()\n    this_will_definitely_fail()\nexcept Exception as err:\n    raise RuntimeError(f\"Something didn't work -- Error: {err}\")\n\n# With py-buzz\nwith handle_errors(\"Something didn't work\", raise_exc_class=RuntimeError):\n    this_could_fail()\n    this_could_also_fail()\n    this_will_definitely_fail()\n</code></pre> <p>This actually can save a bit of code and makes things a bit cleaner. It is also a implements pattern that tends to get repeated over and over again. If you need to do very complicated things while handling an exception, you should use a standard try- catch block. However, there are some extra bells and whistles on <code>handle_errors</code> that can be used by passing additional keyword arguments to the function.</p>"},{"location":"features/#raise_exc_class_2","title":"raise_exc_class","text":"<p>This parameter is the same as for <code>require_condition()</code>. However, if you pass <code>None</code> it will not raise a new exception. Instead, <code>handle_errors</code> will process the <code>do_except</code>, <code>do_else</code>, and <code>do_finally</code> methods and then continue. This effectively absorbs any exceptions that occur in the context. However the context is immediately exited after the first raised exception.</p>"},{"location":"features/#raise_args_2","title":"raise_args","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#raise_kwargs_2","title":"raise_kwargs","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#exc_builder_2","title":"exc_builder","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#handle_exc_class","title":"handle_exc_class","text":"<p>This option describes the type of exception that will be handled by this context manager. Any instance of the option's exception (or any of its derived exception classes) will be caught. This is very useful if you only want to handle a certain category of exceptions and let the others rise up un-altered:</p> <pre><code>with handle_errors(\"Something went wrong\", handle_exc_class=MyProjectError):\n   some_function_that_could_raise_mine_or_other_errors()\n</code></pre> <p>Exception instances that do not fall within the inheritance tree of the <code>handle_exc_class</code> option will not be handled at all. It is worth noting that the <code>do_except</code> task will not be executed if another exception type occurs. However, the <code>do_else</code> and <code>do_finally</code> tasks will be executed normally.</p>"},{"location":"features/#ignore_exc_class","title":"ignore_exc_class","text":"<p>This option describes a type of exception that should not be handled by this context manager. Any instance of the option's exception (or any of its derived exception classes) will be raised immediately by <code>handle_errors</code> and will be not be handled or processed.</p> <p>This is useful if you want a specific variant of your <code>handle_exc_class</code> to not be handled by <code>handle_errors</code>. For example, if you want to use <code>handle_exc_class=Exception</code> but you do not want <code>handle_errors</code> to handle <code>RuntimeError</code>, then, you would set <code>ignore_exc_class=RuntimeError</code>.</p>"},{"location":"features/#do_except","title":"do_except","text":"<p>Often, it is useful to do some particular things when an exception is caught.  Most frequently this includes logging the exception. The <code>do_except</code> optional argument provides the ability to do this. The <code>do_except</code> option should be a callable function that accepts a parameter of type <code>DoExceptParams</code> that can be imported from <code>buzz</code>. This <code>dataclass</code> has three attributes:</p> <ul> <li>err: The caught exception itself</li> <li>final_message: A message describing the error (This will be the formatted error message)</li> <li>trace: A stack trace</li> </ul> <p>This option might be invoked something like this:</p> <pre><code>def log_error(dep: DoExceptParams):\n    logger.error(dep.final_message)\n    logger.error('\\n'.join(dep.trace))\n\nwith handle_errors(\"Something went wrong\", do_except=log_error):\n    some_dangerous_function()\n</code></pre>"},{"location":"features/#do_else","title":"do_else","text":"<p>This option describes some action that should happen if no exceptions are encountered. This option is less useful than <code>do_except</code> but it may useful in some circumstances. This option should be a callable that takes no arguments:</p> <pre><code>    def log_yay():\n        logger.info(\"we did it!\")\n\n    with handle_errors(\"Something went wrong\", do_else=log_yay):\n        some_not_dangerous_function()\n</code></pre>"},{"location":"features/#do_finally","title":"do_finally","text":"<p>This option describes some action that should happen at the end of the context regardless to whether an exception occurred or not. This is a useful feature if you need to do some cleanup in either case. It should take a callable that receives no arguments:</p> <pre><code>def close_resource():\n    resource.close()\n\nwith handle_errors(\"Something went wrong\", do_finally=close_resource):\n    some_dangerous_function_that_uses_resource(resource)\n</code></pre>"},{"location":"features/#exc_builder_3","title":"exc_builder","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#additional-features","title":"Additional Features","text":""},{"location":"features/#check_expressions","title":"check_expressions","text":"<p>The <code>check_expressions</code> context manager is used to check multiple expressions inside of a context manager. Each expression is checked and each failing expression is reported at the end in a raised exception. If no expressions fail in the block, no exception is raised.</p> <pre><code>with check_expressions(main_message='there will be errors') as check:\n    check(True)\n    check(False)\n    check(1 == 2, \"one is not two\")\n    check('cooooooool', 'not a problem')\n    check(0, \"zero is still zero\")\n</code></pre> <p>If the above code was executed, an exception would be raised that looks like this:</p> <pre><code>Exception: Checked expressions failed: there will be errors\n   2: 2nd expression failed\n   3: one is not two\n   5: zero is still zero\n</code></pre> <p>The <code>check_expressions()</code> context manager also accepts some keyword arguments:</p>"},{"location":"features/#raise_exc_class_3","title":"raise_exc_class","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#raise_args_3","title":"raise_args","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#raise_kwargs_3","title":"raise_kwargs","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#exc_builder_4","title":"exc_builder","text":"<p>Functions the same as <code>require_condition</code>.</p>"},{"location":"features/#reformat_exception","title":"reformat_exception","text":"<p>This method is used internally by the <code>handle_errors</code> context manager.  However, it is sometimes useful in other circumstances. It simply allows you to wrap an exception message in a more informative block of text:</p> <pre><code>try:\n    raise ValueError(\"I didn't like that\")\nexcept Exception as err:\n    print(reformat_exception(\"welp...that didn't work\", err))\n</code></pre> <p>The above block would result in output like:</p> <pre><code>&gt; welp...that didn't work -- ValueError: I didn't like that\n</code></pre>"},{"location":"features/#get_traceback","title":"get_traceback","text":"<p>This function is just a tool to fetch the traceback for the current function. It does this by fetching it out of <code>sys.exc_info</code>. It is used internally with Buzz but could be useful in other contexts.</p>"},{"location":"features/#the-buzz-base-class","title":"The Buzz base class","text":"<p>All of the methods described above are attached to the special exception class, <code>Buzz</code>. You could, for example, use this as the base exception type for your project and then access all the functions of <code>py-buzz</code> from that exception type:</p> <pre><code>from buzz import Buzz\n\nclass MyProjectError(Buzz):\n    pass\n\nMyProjectError.require_condition(check_vals(), \"Value check failed!\")\n</code></pre> <p>The code above would raise a <code>MyProjectError</code> with the supplied message if the condition expression was falsey.</p> <p>The <code>Buzz</code> base class provides the same sort of access for <code>handle_errors</code>, <code>enforce_defined</code>, and <code>check_expressions</code>.</p> <p>Check out the examples for more.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#buzz.tools","title":"buzz.tools","text":"<p>This module supplies the core functions of the py-buzz package.</p>"},{"location":"reference/#buzz.tools.DoExceptParams","title":"DoExceptParams  <code>dataclass</code>","text":"<p>Dataclass for the <code>do_except</code> user supplied handling method.</p> <p>Attributes:</p> <pre><code>err:           The exception instance itself\nbase_message:  The base message parameter that was passed to the `handle_errors()` function\nfinal_message: The final, combined message including the base message and string formatted exception\ntrace:         A traceback of the exception\n</code></pre>"},{"location":"reference/#buzz.tools.ExcBuilderParams","title":"ExcBuilderParams  <code>dataclass</code>","text":"<p>Dataclass for the <code>exc_builder</code> user supplied exception constructor.</p> <p>Attributes:</p> <pre><code>raise_exc_class: The exception class that should be built\nmessage:         The message to build the exception with\nraise_args:      The positional arguments that are needed to build the exception\nraise_kwargs:    The keyword arguments that are needed to build the exception\n</code></pre>"},{"location":"reference/#buzz.tools.check_expressions","title":"check_expressions","text":"<pre><code>check_expressions(\n    main_message: str,\n    raise_exc_class: type[Exception] = Exception,\n    raise_args: Iterable[Any] | None = None,\n    raise_kwargs: Mapping[str, Any] | None = None,\n    exc_builder: Callable[\n        [ExcBuilderParams], Exception\n    ] = default_exc_builder,\n)\n</code></pre> <p>Check a series of expressions inside of a context manager. If any fail an exception is raised that contains a main message and a description of each failing expression.</p> <p>Parameters:</p> <ul> <li> <code>main_message</code>               (<code>str</code>)           \u2013            <p>The main failure message to include in the constructed message that is passed to the                raised Exception</p> </li> <li> <code>raise_exc_class</code>               (<code>type[Exception]</code>, default:                   <code>Exception</code> )           \u2013            <p>The exception type to raise with the constructed message if the expression is falsey.</p> <pre><code>           Defaults to Exception.\n\n           May not be None.\n</code></pre> </li> <li> <code>raise_args</code>               (<code>Iterable[Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional positional args (after the constructed message) that will passed when raising                an instance of the <code>raise_exc_class</code>.</p> </li> <li> <code>raise_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword args that will be passed when raising an instance of the <code>raise_exc_class</code>.</p> </li> <li> <code>exc_builder</code>               (<code>Callable[[ExcBuilderParams], Exception]</code>, default:                   <code>default_exc_builder</code> )           \u2013            <p>A function that should be called to construct the raised <code>raise_exc_class</code>. Useful for                exception classes that do not take a message as the first positional argument.</p> </li> </ul> <p>Example:</p> <pre><code>The following is an example usage::\n\n    with check_expressions(\"Something wasn't right\") as check:\n        check(a is not None)\n        check(a &gt; b, \"a must be greater than b\")\n        check(a != 1, \"a must not equal 1\")\n        check(b &gt;= 0, \"b must not be negative\")\n\nThis would render output like::\n\n    Checked expressions failed: Something wasn't right:\n      1: first expressoin failed\n      3: a must not equal 1\n</code></pre>"},{"location":"reference/#buzz.tools.default_exc_builder","title":"default_exc_builder","text":"<pre><code>default_exc_builder(params: ExcBuilderParams) -&gt; Exception\n</code></pre> <p>Build an exception instance using default behavior where message is passed as first positional argument.</p> <p>Some exception types such as FastAPI's HTTPException do not take a message as the first positional argument, so they will need a different exception builder.</p>"},{"location":"reference/#buzz.tools.enforce_defined","title":"enforce_defined","text":"<pre><code>enforce_defined(\n    value: TNonNull | None,\n    message: str = \"Value was not defined (None)\",\n    raise_exc_class: type[Exception] = Exception,\n    raise_args: Iterable[Any] | None = None,\n    raise_kwargs: Mapping[str, Any] | None = None,\n    exc_builder: Callable[\n        [ExcBuilderParams], Exception\n    ] = default_exc_builder,\n) -&gt; TNonNull\n</code></pre> <p>Assert that a value is not None. If the assertion fails, raise an exception with the supplied message.</p> <p>Args:</p> <pre><code>value:            The value that is checked to be non-null\nmessage:          The failure message to attach to the raised Exception\nexpr:             The value that is checked for truthiness (usually an evaluated expression)\nraise_exc_class:  The exception type to raise with the constructed message if the expression is falsey.\n\n                  Defaults to Exception.\n                  May not be None.\n\nraise_args:       Additional positional args (after the constructed message) that will passed when raising\n                  an instance of the ``raise_exc_class``.\nraise_kwargs:     Keyword args that will be passed when raising an instance of the ``raise_exc_class``.\nexc_builder:     A function that should be called to construct the raised ``raise_exc_class``. Useful for\n                 exception classes that do not take a message as the first positional argument.\n</code></pre>"},{"location":"reference/#buzz.tools.get_traceback","title":"get_traceback","text":"<pre><code>get_traceback() -&gt; types.TracebackType | None\n</code></pre> <p>Retrieves the traceback after an exception has been raised.</p>"},{"location":"reference/#buzz.tools.handle_errors","title":"handle_errors","text":"<pre><code>handle_errors(\n    message: str,\n    raise_exc_class: type[Exception] | None = Exception,\n    raise_args: Iterable[Any] | None = None,\n    raise_kwargs: Mapping[str, Any] | None = None,\n    handle_exc_class: type[Exception]\n    | tuple[type[Exception], ...] = Exception,\n    ignore_exc_class: type[Exception]\n    | tuple[type[Exception], ...]\n    | None = None,\n    do_finally: Callable[[], None] = noop,\n    do_except: Callable[[DoExceptParams], None] = noop,\n    do_else: Callable[[], None] = noop,\n    exc_builder: Callable[\n        [ExcBuilderParams], Exception\n    ] = default_exc_builder,\n) -&gt; Iterator[None]\n</code></pre> <p>Provide a context manager that will intercept exceptions and repackage them with a message attached:</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The message to attach to the raised exception.</p> </li> <li> <code>raise_exc_class</code>               (<code>type[Exception] | None</code>, default:                   <code>Exception</code> )           \u2013            <p>The exception type to raise with the constructed message if an exception is caught in the                managed context. If <code>None</code> is passed, no new exception will be raised and only the                <code>do_except</code>, <code>do_else</code>, and <code>do_finally</code> functions will be called.</p> </li> <li> <code>raise_args</code>               (<code>Iterable[Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional positional args (after the constructed message) that will passed when raising                an instance of the <code>raise_exc_class</code>.</p> </li> <li> <code>raise_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword args that will be passed when raising an instance of the <code>raise_exc_class</code>.</p> </li> <li> <code>handle_exc_class</code>               (<code>type[Exception] | tuple[type[Exception], ...]</code>, default:                   <code>Exception</code> )           \u2013            <p>Limits the class of exceptions that will be intercepted                Any other exception types will not be caught and re-packaged.                Defaults to Exception (will handle all exceptions). May also be provided as a tuple                of multiple exception types to handle.</p> </li> <li> <code>ignore_exc_class</code>               (<code>type[Exception] | tuple[type[Exception], ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Defines an exception or set of exception types that should not be handled at all.                Any matching exception types will be immediately re-raised. They will not be handled by                the <code>handle_errors</code> context manager at all. This is useful if you want a specific variant of                your <code>handle_exc_class</code> to not be handled by <code>handle_errors</code>. For example, if you want to use                <code>handle_exc_class=Exception</code> but you do not want <code>handle_errors</code> to handle <code>RuntimeError</code>.                Then, you would set <code>ignore_exc_class=RuntimeError</code>.</p> </li> <li> <code>do_finally</code>               (<code>Callable[[], None]</code>, default:                   <code>noop</code> )           \u2013            <p>A function that should always be called at the end of the block.                Should take no parameters.</p> </li> <li> <code>do_except</code>               (<code>Callable[[DoExceptParams], None]</code>, default:                   <code>noop</code> )           \u2013            <p>A function that should be called only if there was an exception. Must accept one                parameter that is an instance of the <code>DoExceptParams</code> dataclass.                Note that the <code>do_except</code> method is passed the original exception.</p> </li> <li> <code>do_else</code>               (<code>Callable[[], None]</code>, default:                   <code>noop</code> )           \u2013            <p>A function that should be called only if there were no exceptions encountered.</p> </li> <li> <code>exc_builder</code>               (<code>Callable[[ExcBuilderParams], Exception]</code>, default:                   <code>default_exc_builder</code> )           \u2013            <p>A function that should be called to construct the raised <code>raise_exc_class</code>. Useful for                exception classes that do not take a message as the first positional argument.</p> </li> </ul> <p>Example:</p> <pre><code>The following is an example usage:\n\n    with handle_errors(\"It didn't work\"):\n        some_code_that_might_raise_an_exception()\n</code></pre>"},{"location":"reference/#buzz.tools.handle_errors_async","title":"handle_errors_async  <code>async</code>","text":"<pre><code>handle_errors_async(\n    message: str,\n    raise_exc_class: type[Exception] | None = Exception,\n    raise_args: Iterable[Any] | None = None,\n    raise_kwargs: Mapping[str, Any] | None = None,\n    handle_exc_class: type[Exception]\n    | tuple[type[Exception], ...] = Exception,\n    ignore_exc_class: type[Exception]\n    | tuple[type[Exception], ...]\n    | None = None,\n    do_finally: Callable[[], None]\n    | Callable[[], Coroutine[Any, Any, None]] = noop,\n    do_except: Callable[[DoExceptParams], None]\n    | Callable[\n        [DoExceptParams], Coroutine[Any, Any, None]\n    ] = noop,\n    do_else: Callable[[], None]\n    | Callable[[], Coroutine[Any, Any, None]] = noop,\n    exc_builder: Callable[\n        [ExcBuilderParams], Exception\n    ] = default_exc_builder,\n) -&gt; AsyncIterator[None]\n</code></pre> <p>Provide an async context manager that will intercept exceptions and repackage them with a message attached:</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The message to attach to the raised exception.</p> </li> <li> <code>raise_exc_class</code>               (<code>type[Exception] | None</code>, default:                   <code>Exception</code> )           \u2013            <p>The exception type to raise with the constructed message if an exception is caught in the                managed context. If <code>None</code> is passed, no new exception will be raised and only the                <code>do_except</code>, <code>do_else</code>, and <code>do_finally</code> functions will be called.</p> </li> <li> <code>raise_args</code>               (<code>Iterable[Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional positional args (after the constructed message) that will passed when raising                an instance of the <code>raise_exc_class</code>.</p> </li> <li> <code>raise_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword args that will be passed when raising an instance of the <code>raise_exc_class</code>.</p> </li> <li> <code>handle_exc_class</code>               (<code>type[Exception] | tuple[type[Exception], ...]</code>, default:                   <code>Exception</code> )           \u2013            <p>Limits the class of exceptions that will be intercepted                Any other exception types will not be caught and re-packaged.                Defaults to Exception (will handle all exceptions). May also be provided as a tuple                of multiple exception types to handle.</p> </li> <li> <code>ignore_exc_class</code>               (<code>type[Exception] | tuple[type[Exception], ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Defines an exception or set of exception types that should not be handled at all.                Any matching exception types will be immediately re-raised. They will not be handled by                the <code>handle_errors</code> context manager at all. This is useful if you want a specific variant of                your <code>handle_exc_class</code> to not be handled by <code>handle_errors</code>. For example, if you want to use                <code>handle_exc_class=Exception</code> but you do not want <code>handle_errors</code> to handle <code>RuntimeError</code>.                Then, you would set <code>ignore_exc_class=RuntimeError</code>.</p> </li> <li> <code>do_finally</code>               (<code>Callable[[], None] | Callable[[], Coroutine[Any, Any, None]]</code>, default:                   <code>noop</code> )           \u2013            <p>A function that should always be called at the end of the block.                Should take no parameters.                May be an async function.</p> </li> <li> <code>do_except</code>               (<code>Callable[[DoExceptParams], None] | Callable[[DoExceptParams], Coroutine[Any, Any, None]]</code>, default:                   <code>noop</code> )           \u2013            <p>A function that should be called only if there was an exception. Must accept one                parameter that is an instance of the <code>DoExceptParams</code> dataclass.                May be an async function.                Note that the <code>do_except</code> method is passed the original exception.</p> </li> <li> <code>do_else</code>               (<code>Callable[[], None] | Callable[[], Coroutine[Any, Any, None]]</code>, default:                   <code>noop</code> )           \u2013            <p>A function that should be called only if there were no exceptions encountered.                May be an async function.</p> </li> <li> <code>exc_builder</code>               (<code>Callable[[ExcBuilderParams], Exception]</code>, default:                   <code>default_exc_builder</code> )           \u2013            <p>A function that should be called to construct the raised <code>raise_exc_class</code>. Useful for                exception classes that do not take a message as the first positional argument.</p> </li> </ul> <p>Example:</p> <pre><code>The following is an example usage:\n\n    async with handle_errors(\"It didn't work\"):\n        await some_code_that_might_raise_an_exception()\n</code></pre>"},{"location":"reference/#buzz.tools.reformat_exception","title":"reformat_exception","text":"<pre><code>reformat_exception(message: str, err: Exception) -&gt; str\n</code></pre> <p>Reformat an exception by adding a message to it and reporting the original exception name and message.</p>"},{"location":"reference/#buzz.tools.require_condition","title":"require_condition","text":"<pre><code>require_condition(\n    expr: Any,\n    message: str,\n    raise_exc_class: type[Exception] = Exception,\n    raise_args: Iterable[Any] | None = None,\n    raise_kwargs: Mapping[str, Any] | None = None,\n    exc_builder: Callable[\n        [ExcBuilderParams], Exception\n    ] = default_exc_builder,\n)\n</code></pre> <p>Assert that an expression is truthy. If the assertion fails, raise an exception with the supplied message.</p> <p>Args:</p> <pre><code>message:         The failure message to attach to the raised Exception\nexpr:            The value that is checked for truthiness (usually an evaluated expression)\nraise_exc_class: The exception type to raise with the constructed message if the expression is falsey.\n                 Defaults to Exception.\n                 May not be None.\nraise_args:      Additional positional args (after the constructed message) that will passed when raising\n                 an instance of the ``raise_exc_class``.\nraise_kwargs:    Keyword args that will be passed when raising an instance of the ``raise_exc_class``.\nexc_builder:     A function that should be called to construct the raised ``raise_exc_class``. Useful for\n                 exception classes that do not take a message as the first positional argument.\n</code></pre>"},{"location":"reference/#buzz.base","title":"buzz.base","text":"<p>This module defines the Buzz base class.</p>"},{"location":"reference/#buzz.base.Buzz","title":"Buzz","text":"<p>               Bases: <code>Exception</code></p> <p>This provides a specialized exception class that wraps up all the buzz utility functions.</p>"},{"location":"reference/#buzz.base.Buzz.__init__","title":"__init__","text":"<pre><code>__init__(message: str)\n</code></pre> <p>Initialize the exception with a message.</p> <p>Also, dedent the supplied message.</p>"},{"location":"reference/#buzz.base.Buzz.check_expressions","title":"check_expressions  <code>classmethod</code>","text":"<pre><code>check_expressions(*args: Any, **kwargs: Any)\n</code></pre> <p>Call the <code>check_expressions()</code> context manager with this class as the <code>raise_exc_class</code> kwarg.</p>"},{"location":"reference/#buzz.base.Buzz.enforce_defined","title":"enforce_defined  <code>classmethod</code>","text":"<pre><code>enforce_defined(\n    value: TNonNull | None, *args: Any, **kwargs: Any\n) -&gt; TNonNull\n</code></pre> <p>Call the <code>enforce_defined()</code> function with this class as the <code>raise_exc_class</code> kwarg.</p>"},{"location":"reference/#buzz.base.Buzz.get_traceback","title":"get_traceback  <code>classmethod</code>","text":"<pre><code>get_traceback(*args: Any, **kwargs: Any)\n</code></pre> <p>Call the <code>get_traceback()</code> function.</p>"},{"location":"reference/#buzz.base.Buzz.handle_errors","title":"handle_errors  <code>classmethod</code>","text":"<pre><code>handle_errors(\n    *args: Any, re_raise: bool = True, **kwargs: Any\n)\n</code></pre> <p>Call the <code>handle_errors()</code> context manager with this class as the <code>raise_exc_class</code> kwarg.</p> <p>Note:</p> <pre><code>If `re_raise` is not True, `None` will be passed as the `raise_exc_class` kwarg.\n</code></pre>"},{"location":"reference/#buzz.base.Buzz.require_condition","title":"require_condition  <code>classmethod</code>","text":"<pre><code>require_condition(*args: Any, **kwargs: Any)\n</code></pre> <p>Call the <code>require_condition()</code> function with this class as the <code>raise_exc_class</code> kwarg.</p>"}]}